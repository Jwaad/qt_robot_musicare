#!/usr/bin/env python
# This code is the only node that needs to be run, instead of opening 3 different nodes before starting.

import rospy
import roslaunch
import rosnode
import pickle
import random
import pygame
import os
from musicare_lib import Renderer
from musicare_lib import Button
from musicare_lib import AnimationManager
from musicare_lib import InputBox
from musicare_lib import StandardLevels
from musicare_lib import Behaviours
from musicare_lib import General
from guess_mood import Guess_The_Mood_Game as GTM
from fix_song import Fix_The_Song_Game as FTS
from clap_beat import Clap_To_Beat_Game as CTB
from simon_says_clap import Simon_Says_Clap_Game as SSC
import time
import glob

class GameManager():

    # On start: check if we are connected to robot and decide which nodes to run
    def __init__(self):
        # Init vars
        self.debug = True
        self.run = True
        self.path_to_music = "game_assets/music/"
        this_file_path = os.path.dirname(__file__)
        self.path_to_userdata = os.path.join(this_file_path, 'game_assets/data/user_data/')
        self.session_time = 1 * 60 # 15 * 60  # Time in seconds that sessions should last for. (Minimum time)
        self.session_name = "session_" # this should be appended with a number e.g: session_3
        self.session_data = {}
        self.game_names = ["GTM", "FTS", "CTB", "SSC"]
        self.prev_game = ""

        # Init ros side
        rospy.init_node('GameManager', anonymous=False)
        self.PingNode = "/qt_motor"
        self.musicarePkgName = "musi_care"
        self.jwaadTestPkgName = "jwaad_test"
        self.ActiveNodes =[] # Store reference to all nodes that we start

        # Check robot connected
        robot_connected = self.CheckRobotRunning()
        rospy.set_param('/activity_status', 1) # Tell ros this node is starting
        if robot_connected:
            self.StartRobotNodes()
        else:
            self.StartSimulatedRobotNodes()
        self.StartLaptopNodes()

        # Init libraries / tool boxes
        self.InitPygame()
        self.animation_manager = AnimationManager(self.pygame)
        self.behaviours_manager = Behaviours(self.pygame, self.path_to_music)
        self.general_functions = General()
        self.Levels = StandardLevels(self.window, self.window_center, self.pygame, self.path_to_music, debug=self.debug)
        self.renderer = Renderer(self.window, self.window_center)

        # Hide cursor
        if not self.debug:
            self.pygame.mouse.set_visible(False)  # set to false when not testing


    def InitPygame(self):
        self.run = True
        self.pygame = pygame
        self.pygame.init()  # start py engine
        self.pygame.freetype.init()
        self.FPS = 30
        self.clock = self.pygame.time.Clock()
        os.environ['SDL_VIDEO_WINDOW_POS'] = '%d,%d' % (150, 0)  # move screen to account for toolbar
        self.window_x = 2850
        self.window_y = 2000
        # res = pygame.display.Info()  # get our screen resolution
        # self.window_x = res.current_w - 150  # Width of window -150 to account for the linux toolbar
        # self.window_y = res.current_h  # Height of window
        self.window_center = (int(self.window_x / 2), int(self.window_y / 2))
        self.cen_x = self.window_center[0]
        self.cen_y = self.window_center[1]
        self.window = pygame.display.set_mode((self.window_x, self.window_y))  # Create window and set size
        self.background_colour = (100, 100, 100)  # background Gray by default
        self.pygame.display.set_caption("MusiCare Cognitive Games with QT robot")  # Label window

    def create_button(self, file_name, location, return_info=None, scale=1.0, unique_id="", text="",
                      on_click=None, on_release=None):
        """code creates button using the button_image class."""
        if return_info is None:
            return_info = {}
        this_file_path = os.path.dirname(__file__)
        relative_path = 'game_assets/graphics'
        file_path = os.path.join(this_file_path, relative_path, file_name)

        button = Button(file_path, location, self.pygame, return_info = {}, scale=scale, unique_id=unique_id,
                        text=text, on_click=on_click, on_release=on_release)
        return button

    # Check if the robot is connected, by calling nodes and seeing if we get a response
    def CheckRobotRunning(self):
        rospy.loginfo("Checking if robot is connected to laptop")
        robot_connected = rosnode.rosnode_ping(self.PingNode, max_count=3)
        if robot_connected:
            rospy.loginfo("Connecting to robot and running nodes")
        else:
            rospy.loginfo("Could not detect robot, running in offline mode")
        return robot_connected

    # SSH into robot and start QT command node
    def StartRobotNodes(self):
        nodeName = 'qt_command_node'
        node = self.StartNode(self.musicarePkgName, nodeName)
        time.sleep(1)
        self.ActiveNodes.append(node)

    # Start the laptop side fake node that just takes in the commands and prints them
    def StartSimulatedRobotNodes(self):
        nodeName = 'laptop_command'
        node = self.StartNode(self.jwaadTestPkgName, nodeName)
        time.sleep(1)
        self.ActiveNodes.append(node)

    # Start the sound player on laptop side
    def StartLaptopNodes(self):
        nodeName = 'sound_player'
        node = self.StartNode(self.musicarePkgName, nodeName)
        time.sleep(1)
        self.ActiveNodes.append(node)

    # Run some code before we close out of this node (Ros does this automatically, but we do it again anyways, just incase)
    def OnExit(self):
        # Save user data
        self.SaveExistingUserData()

        # End pygame
        self.pygame.quit()

        # Close all the nodes we started on launch (though this happens automatically)
        rospy.loginfo("Exiting...")
        for node in self.ActiveNodes:
            node.stop()

        rospy.set_param('/activity_status', 0)  # Tell ros this node is ended

        # END ROSCORE HERE, maybe?
        print("Ending...")


    # Start a node and store the reference to it
    def StartNode(self, nodePackage, nodeName):
        node = roslaunch.core.Node(nodePackage, nodeName)

        launch = roslaunch.scriptapi.ROSLaunch()

        launch.start()
        nodeRef = launch.launch(node)
        return nodeRef

    def LoadUserDatabase(self):
        """ Load all users into memory, so we can  """
        self.user_database = []
        
        users = []
        # Get list of all users
        users = glob.glob(self.path_to_userdata + "/*.p")
        if users == []:
            return self.user_database
        for path in users:
            user_data = {}
            with open(path, "rb") as f:
                print("attempting to open {0}".format(path))
                user_data = pickle.load(f)
            self.user_database.append(user_data)

        # Also extract / update names, for log in screen
        self.first_names = []
        self.surnames = []
        for user in self.user_database:
            self.first_names.append(user["name"])
            self.surnames.append(user["surname"])

        return self.user_database

    def SaveNewUser(self, name, surname, DoB):
        """
        Save a New User to System
        name = string of first name
        surname = string of last name
        DoB = string of Date of birth in format dd-mm-yy as integers. e.g: 01-01-99
        """
        file_name = name[0] + surname[0] + DoB + ".p"

        # Format data of new user
        data = {}
        data["name"] = name # first name
        data["surname"] = surname # surnanme
        data["dob"] = DoB # dob in format dd-mm-yyyy
        data["blacklist"] = [] # songs which receive negative survey
        data["song_preference"] = {}  #
        data["game_data"] = {"difficulty": {"GTM":"easy", "FTS":"easy", "CTB":"easy", "SSC":"easy"} }

        # Get path and save
        file_path = os.path.join(self.path_to_userdata, file_name)

        # Save to file if it doesnt exist already
        if not os.path.exists(file_path):
            open(file_path, "w").close()
            with open(file_path, "wb") as f:
                pickle.dump(data, f)
            rospy.loginfo("User data saved to {0}".format(file_path))
        else:
            rospy.loginfo("User data not saved, user already exists.")
        return data

    def SaveExistingUserData(self, user ={}):
        """
        Overwrite the save data of an existing user. Can specify user.
        If user is not specified will assume there's a user in memory stored in "self.user_data"
        """
        if user == {} or user is None:
            user = self.user_data

        file_name = user["name"][0] + user["surname"][0] + user["dob"] + ".p"

        # Get path and save
        file_path = os.path.join(self.path_to_userdata, file_name)

        # Save to file if it doesnt exist already
        open(file_path, "w").close()
        with open(file_path, "wb") as f:
            pickle.dump(user, f)
        rospy.loginfo("User data saved to {0}".format(file_path))
        return user

    def SignupScreen(self):

        # Input / text boxes
        name_box = InputBox(600, 300, 1000, 200, "First Name")
        surname_box = InputBox(600, 700, 1000, 200, "Last Name")
        dob_box = InputBox(600, 1100, 1000, 200, "dd-mm-yyyy", allowed_chars="0123456789", max_chars=10)
        inputboxes = [name_box, surname_box, dob_box]
        # Check marks
        name_tick = self.create_button("check_mark.png", (1750, 325))
        surname_tick = self.create_button("check_mark.png", (1750, 725))
        dob_tick = self.create_button("check_mark.png", (1750, 1125))
        ticks = {}
        #ticks = {1: name_tick, 2: surname_tick, 3: dob_tick}
        # Buttons
        back_button = self.create_button("tut_back.png", (20, 20))
        confirm_button = self.create_button("blank_button.png", (900, 1500), text="Done")
        buttons = [back_button, confirm_button]


        back = False
        while (not rospy.is_shutdown()) and (self.run) and not back:

            # Handle events
            mouse_pos = self.pygame.mouse.get_pos()
            for event in self.pygame.event.get():

                # Handle events for name box
                event_triggered = name_box.handle_event(event)
                if event_triggered == "KEYDOWN":
                    if (name_box.get_text() is not None) and (name_box.get_text() != ""):
                        ticks["name"] = name_tick
                    else:
                        # If tick is already in our dict, remove it
                        if "name" in ticks:
                            del ticks["name"]

                # Handle events for surname box
                event_triggered = surname_box.handle_event(event)
                if event_triggered == "KEYDOWN":
                    if (surname_box.get_text() is not None) and (surname_box.get_text() != ""):
                        ticks["surname"] = surname_tick
                    else:
                        if "surname" in ticks:
                            del ticks["surname"]

                # Handle events for dob box
                event_triggered = dob_box.handle_event(event)
                if event_triggered == "KEYDOWN":
                    # Add the - at set intervals
                    if event.key != pygame.K_BACKSPACE:
                        if len(dob_box.get_text()) in [2, 5]:
                            dob_box.text += "-"
                    # If backspace over a "-", then take additional char
                    else:
                        if len(dob_box.get_text()) in [3, 6]:
                            dob_box.text = dob_box.text[:-1]
                    # Check length is correct for dob:
                    if len(dob_box.get_text()) == 10:
                        ticks["dob"] = dob_tick
                    else:
                        if "dob" in ticks:
                            del ticks["dob"]

                # Check back button and done button
                back = back_button.get_event(event, mouse_pos)
                done_clicked = confirm_button.get_event(event, mouse_pos)

                # Check "Done"
                if len(ticks.values()) == 3:
                    if done_clicked:
                        new_user = self.SaveNewUser(name_box.get_text(), surname_box.get_text(), dob_box.get_text())
                        self.LoadUserDatabase()
                        back = True
                        print(new_user)

                # Handle on click animation
                if event.type == self.pygame.MOUSEBUTTONUP:  # On mouse release play animation to show where cursor is
                    self.animation_manager.StartTouchAnimation(mouse_pos)  # Play animation

                # Check quit
                if event.type == pygame.QUIT:
                    self.run = False
                    print("Quitting...")

            # Draw background
            self.renderer.DrawBackground(self.background_colour)

            # Update graphics
            for button in buttons:
                button.render(self.window)
            for box in inputboxes:
                box.render(self.window)
            if len(ticks.values()) > 0:
                for tick in ticks.values():
                    tick.render(self.window)
            self.animation_manager.DrawTouchAnimation(self.window)
            self.pygame.display.update()  # Update all drawn objects

            # Cap FPS (save resources)
            self.clock.tick(self.FPS)

    def LogInScreen(self):
        """
        Use database, and check if user is inputting credentials we have seen before.
        Once a user is logged in, this method also sets "self.session_name" to the current number.
        """

        # Input / text boxes
        name_box = InputBox(200, 600, 1000, 200, "First Name")
        surname_box = InputBox(1600, 600, 1000, 200, "Last Name")
        inputboxes = [name_box, surname_box]
        # Check marks
        name_tick = self.create_button("check_mark.png", (650, 800))
        surname_tick = self.create_button("check_mark.png", (2050, 800))
        ticks = {}
        # Buttons
        next_button = self.create_button("next_button.png", (1100, 1200))
        signup_button = self.create_button("blank_button.png", (2300, 20), text="New User", scale=0.5)

        log_in = False
        user_recognised = False
        correct_surname = "#}$"
        while (not rospy.is_shutdown()) and (self.run) and not log_in:

            # Handle events
            mouse_pos = self.pygame.mouse.get_pos()
            for event in self.pygame.event.get():

                # Handle on click animation
                if event.type == self.pygame.MOUSEBUTTONUP:  # On mouse release play animation to show where cursor is
                    self.animation_manager.StartTouchAnimation(mouse_pos)  # Play animation

                # Handle events for name box
                event_triggered = name_box.handle_event(event)
                if event_triggered == "KEYDOWN":
                    if name_box.get_text() in self.first_names:
                        ticks["name"] = name_tick
                        # Get the corresponding surname
                        ind = self.first_names.index(name_box.get_text())
                        correct_surname = self.surnames[ind]
                    else:
                        # If tick is already in our dict, remove it
                        if "name" in ticks:
                            del ticks["name"]
                            user_recognised = False
                            correct_surname = "#}$"

                # Handle events for surname box
                event_triggered = surname_box.handle_event(event)
                if event_triggered == "KEYDOWN":
                    if surname_box.get_text() == correct_surname:
                        ticks["surname"] = surname_tick
                        user_recognised = True
                    else:
                        # If tick is already in our dict, remove it
                        if "surname" in ticks:
                            del ticks["surname"]
                            user_recognised = False
                            correct_surname = "#}$"

                # Handle event for next button
                next_clicked = next_button.get_event(event, mouse_pos)
                if next_clicked:
                    if user_recognised:
                        self.user_data = self.user_database[self.surnames.index(surname_box.get_text())]
                        log_in = True
                    else:
                        #TODO add flash or simple animation, to show wrong user here.
                        print("Animation just played, did you see it?")

                # Handle event for new user
                signup = signup_button.get_event(event, mouse_pos)
                if signup:
                    self.SignupScreen()

                # Check quit
                if event.type == pygame.QUIT:
                    self.run = False
                    print("Quitting...")

            # Draw background
            self.renderer.DrawBackground(self.background_colour)

            # Update graphics
            for box in inputboxes:
                box.render(self.window)
            if len(ticks.values()) > 0:
                for tick in ticks.values():
                    tick.render(self.window)
            next_button.render(self.window)
            signup_button.render(self.window)
            self.animation_manager.DrawTouchAnimation(self.window)
            self.pygame.display.update()  # Update all drawn objects

            # Cap FPS (save resources)
            self.clock.tick(self.FPS)

        # Get what session this is
        self.count_session()

        return self.user_data

    def mood_comment(self, mood_rating):
        """ Using the mood of the user, robot should say something"""
        # max_mood = 7 # the highest and happiest score possible.
        neutral_rating = 3

        # Positive rating
        if mood_rating > neutral_rating:
            # "Thats good" type message
            sayings = ["Thats great news! Then lets get straight into playing!",
                       "I'm so happy to hear that! Then.. lets play some games and have some fun!",
                       "Thats perfect! Then we will enjoy the games even more!",
                       "That makes me happy too! We're going to have so much fun playing these games!"
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = "arms_up"
        # Negative rating
        elif mood_rating < neutral_rating:
            # "That's too bad" type message
            sayings = ["Oh... Thats too bad. Hopefully playing games will cheer you up!",
                       "Oh... Thats too bad. Maybe playing with me can help a bit!",
                       "I'm sorry to hear. Lets play some games! maybe that will make you feel happier",
                       "Maybe playing these games will make you feel more cheerful!",
                       "Oh no! Then, in that case. Hopefully i can cheer you up with the games we'll play!"
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = "shake_head"
        # Neutral rating
        else:
            # "oh? lets fix that" type message
            sayings = ["Hmm, okay maybe playing games will make you feel livelier!",
                       "Oh, okay. Then lets play games. Maybe you'll feel more cheerful after!",
                       "okay. Then... Lets play some games. It might make you feel happier!"
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = ""

        if gesture == "":
            self.Levels.QTSpeakingScreen(message, self.run, self.background_colour)
        else:
            self.Levels.QTSpeakingScreen(message, self.run, self.background_colour, should_gesture=True,
                                     gesture=gesture)

    def count_session(self):
        """
        Loop through data and figure out what session we're in
        this sets self.session_name.
        e.g: loop through data, and find there's 4 keys with string "session" in them.
        then set session_name to session_5
        """
        game_data = self.user_data["game_data"]
        session_num = 1 #start at 1, so we always 1 more than sessions total
        for key in game_data.keys():
            if "session_" in key:
                session_num += 1

        self.session_name += str(session_num)
        return session_num

    def count_games(self):
        """
        Method to return the correct string to save game data under.
        Read current user data and returns a string of the next game_num
        """
        if self.session_name not in self.user_data["game_data"].keys():
            return "game_1"
        session_data = self.user_data["game_data"][self.session_name]

        num_games = 1 # start at 1, to add 1 to result
        for key in session_data.keys():
            if "game_" in key:  # All keys in session should contain "game_", but just in case i add more later
                num_games += 1

        return "game_" + str(num_games)

    def get_latest_data(self, session_name = "", game_name = ""):
        """
        Loop through a given session, and retreive data of most recent game. Can specify a game type.
        Must be called after a user is already loaded into memory and stored in self.user_data
        session_name = string, should be the name of a previous session. if no name is given, then uses current session
            (self.session_name)
        game_name = string, if no game is given, returns the latest game of any type
        If no prior level data exists, then return None
        """
        if session_name == "" or session_name == None:
            session_name = self.session_name

        if session_name not in self.user_data["game_data"].keys():
            print("GLD: session data not found")
            return None

        session_data = self.user_data["game_data"][session_name]

        lastest_game = -10
        if len(session_data.keys()) > 0:
            for key in session_data.keys():
                if "game_" in key: # All keys in session should contain "game_", but just in case i add more later
                    split_key = key.split("_")
                    game_num = int(split_key[1]) # convert the number after the "_" into an int
                    # If no game_name specified, just use int
                    if game_name == "" or game_name == None:
                        if game_num > lastest_game:
                            lastest_game = game_num
                    else:
                        # otherwise, only compare if they're the same game type
                        if session_data[key]["game_name"] == game_name:
                            #print("Prev game found")
                            if game_num > lastest_game:
                                lastest_game = game_num
        # if no level data, or no specific game data return None
        if lastest_game < 1:
            print("GLD: No previous games found in session")
            return None
        level_name = "game_" + str(lastest_game)
        level_data = self.user_data["game_data"][session_name][level_name]
        return level_data

    def QTPreamble(self, user):
        name = user["name"]

        # If this is a new user act differently
        if self.session_name == "session_1":
            s_1 = "Hi {}! It's so nice to meet you!... My name is QT robot.".format(name)
            s_2 = "Unfortunately. I can not understand human language..."
            s_3 = "If you want to interact with me, you will need to use the screen."
            s_4 = "Anyways!"

            dialogue = [s_1, s_2, s_3, s_4]
            gestures = ["wave", "shake_head", "explain_right", "" ]
            for i in range(0, len(dialogue)):
                if gestures[i] == "":
                    self.Levels.QTSpeakingScreen(dialogue[i], self.run, self.background_colour)
                else:
                    self.Levels.QTSpeakingScreen(dialogue[i], self.run, self.background_colour, should_gesture = True,
                                                 gesture = gestures[i])
                time.sleep(1) # Add 1s delay between sentences
        else:
            # Use a randomised greeting
            self.Levels.QTSpeakingScreen(self.behaviours_manager.get_greetings(), self.run, self.background_colour, should_gesture=True,
                                         gesture="wave")

        # Ask user how they are, save to data
        #TODO  RANDOMISED WAYS TO ASK HOW ARE YOU
        mood_score = 5 # TODO HOW ARE YOU SCREEN
        self.user_data["game_data"][self.session_name]["mood_pre"] = mood_score

        # QT should comment based on their mood e.g: "Oh, hopefully these games cheer you up"
        self.mood_comment(mood_score)

        # introduce the start of the games

    def QTPostamble(self, user = None):
        """
        Handle QT behaviour post session
        """
        if user is None:
            user = self.user_data
        name = user["name"]

        # Use a randomised greeting
        # TODO randomised sayings of "that was so fun, im so excited for next week."
        self.Levels.QTSpeakingScreen(self.behaviours_manager.get_greetings(), self.run, self.background_colour, should_gesture=True,
                                     gesture="wave")

        # Ask user how they are, save to data
        #TODO  RANDOMISED WAYS TO ASK HOW ARE YOU
        mood_score = 7 # TODO HOW ARE YOU SCREEN
        self.user_data["game_data"][self.session_name]["mood_post"] = mood_score

        # QT should comment based on their mood e.g: "Oh, hopefully these games cheer you up"
        # TODO RANDOMISED, I'm HAPPY THAT YOUR MOOD WENT UP / THATS A SHAME THAT YOU STILL FEEL DOWN etc
        self.mood_comment(mood_score)


    def change_difficulty(self, game_name, clear_type):
        """
        Takes in game name and clear type, then checks through current user data,
        to check if user should move up or down in difficulty or that game type
        2 E_clears in a row = move up
        2 fails in a row = move down
        2 clears in a row = do nothing
        This must be called before the latest game data was saved, or it will compare itself to itself

        game_name = string, GTM, FTS, CTB, SSC
        clear_type = string, e_clear, clear, fail
        """

        # Get the data of the previous game played, in this session
        prev_game = self.get_latest_data(game_name = game_name)

        # Guard statement #1
        if prev_game is None:
            #print("no previous game data, skipping")
            return

        # Guard statement #2
        prev_clear = prev_game["clear_type"]
        if prev_clear != clear_type:
            return

        # Increase or decrease difficulty
        current_difficulty = self.user_data["game_data"]["difficulty"][game_name]
        if clear_type == "clear":
            return
        elif clear_type == "fail":
            if current_difficulty == "easy":
                print("difficulty already at lowest")
                return # if we cant get any easier, just return
            print("decreasing difficulty")
            if current_difficulty == "medium":
                self.user_data["game_data"]["difficulty"][game_name] = "easy"
            elif current_difficulty == "hard":
                self.user_data["game_data"]["difficulty"][game_name] = "medium"
            return
        elif clear_type == "e_clear":
            if current_difficulty == "hard":
                print("difficulty already at highest")
                return # if we cant get any harder, just return
            print("increasing difficulty")
            if current_difficulty == "medium":
                self.user_data["game_data"]["difficulty"][game_name] = "hard"
            elif current_difficulty == "easy":
                self.user_data["game_data"]["difficulty"][game_name] = "medium"
            # QT congratulatory message
            self.Levels.QTSpeakingScreen(self.behaviours_manager.get_next_difficulty(), self.run, self.background_colour,
                                         should_gesture=True,
                                         gesture="arms_up")
            return


    def play_games(self):
        """
        semi-randomly selects a game to play, from those added into "self.games"
        randomly selects from the games that have been played least.
        Also increases or decreases difficulty as needed and saves user data after each level
        """

        self.games = ["GTM", "GTM", "GTM", "GTM" ] # TEMP, REMOVE LATER TODO

        # Populate a list of counters for each game type
        this_session = []
        for game in self.games:
            this_session.append(0) # [0,0,0,0]

        play_time = 0
        time_start = rospy.get_time()
        game_num = 0
        # Keep selecting games to be played until full time has passed
        while play_time < (self.session_time):
            # Keep track of what how many games we've played.
            game_num += 1

            # Populate new list of the games which have been played the least, and randomly select from that list
            min_value = min(this_session)
            selectable_games = []
            for i, x in enumerate(this_session):
                if x == min_value:
                    selectable_games.append(i)
            if len(selectable_games) == 1:
                selected_game_ind =  selectable_games[0]
            else:
                selected_game_ind = random.choice(selectable_games)
            game_name = self.games[selected_game_ind]
            self.prev_game = game_name
            this_session[selected_game_ind] += 1

            # Get difficulty from user profile
            difficulty = self.user_data["game_data"]["difficulty"][game_name]
            play_tut = False
            if difficulty == "easy":
                play_tut = True

            # Play game
            performance = self.play_game(game_name, difficulty, play_tut)

            # Check if difficulty should increase or decrease
            clear_type = performance["clear_type"]
            self.change_difficulty(game_name, clear_type)

            # Add performance to data and save
            game_save_name = "game_" + str(game_num)
            self.user_data["game_data"][self.session_name][game_save_name] = performance
            self.SaveExistingUserData()

            # update play time
            play_time = rospy.get_time() - time_start


    def play_game(self, game_name, difficulty, play_tut):
        """
        Method to load and launch specified game at specified difficulty
        game_name = string, GTM, FTS, CTB, SSC
        difficulty = string, tut, easy, medium, hard
        play_tut = bool, whether or not the game should ask if tut should be shown
        """
        performance = {}

        # Play GTM
        if game_name == "GTM":
            # Init game
            game = GTM(debug=self.debug)

            # Load all game data
            song_data = self.general_functions.Load_Song_Data("GTM")

            # Choose random song from database, depending on difficulty specified
            levels = song_data[difficulty] # load all songs and store relevant difficulty
            # pop the previous song from this list, to prevent repetition
            prev_level = self.get_latest_data(game_name = game_name)
            if prev_level is not None:
                if prev_level["difficulty"] == difficulty: # prevents key error (dont pop an easy song from the med list)
                    levels.pop(prev_level["song_title"])

            i = random.randint(0, len(levels) - 1) # choose random one
            song_title = list(levels.keys())[i]  # There's only 1 key, and it's the songs title
            # Keep randomising til we play a non-blacklisted song
            while song_title in self.user_data["blacklist"]:
                i = random.randint(0, len(levels.keys()) - 1)  # choose random one
                song_title = list(levels.keys())[i]  # There's only 1 key, and it's the songs title
                levels.pop(i)  # remove song from level data, and re randomise
                # If we've popped out all songs, just use the last 1 left
                if len(levels) < 1:
                    break

            # Get out the required information to play game
            level_data = levels[song_title]
            mood = level_data["mood"]
            file_name = level_data["file_name"]

            # Play game
            self.run, performance = game.Main(mood, file_name, play_tut)
            performance["song_title"] = song_title
            performance["difficulty"] = difficulty

        return performance

    def data_printout(self, user, save_to_file = False):
        """
        Print out the data of the user in a nice formatted string
        Recursively loops through dicts in the dict, and adds indentation
        """
        def add_data_to_string(mydict, string_data, loop_num):
            indent = (loop_num * "    ")
            for key in mydict.keys():
                if type(mydict[key]) == dict:
                    string_data += indent + str(key) + ":\n"
                    string_data = add_data_to_string(mydict[key], string_data, loop_num + 1) # ITS REWIND TIME
                elif type(mydict[key]) == list:
                    string_data += indent + str(key) + ": " + str(mydict[key]) + "\n"
                else:
                    string_data += indent + str(key) + ": " +  str(mydict[key]) + "\n"
            return string_data

        data = ""
        data = add_data_to_string(user, data, 0)

        if save_to_file:
            file_name = user["name"][0] + user["surname"][0] + user["dob"] + "_Readout.txt"
            file_path = os.path.join(self.path_to_userdata, file_name)

            with open(file_path, "w") as text_file:
                text_file.write(data)
            rospy.loginfo("Formatted readout, saved to {0}".format(file_path))
        else:
            print()
            print(data)

    # Create GUI to control which level to play
    def Main(self):

        # Load all users into memory
        self.LoadUserDatabase()

        # use name and surname to get user data
        self.LogInScreen()
        # Init the session
        self.user_data["game_data"][self.session_name] = {}

        # What QT should say to the returning or new user
        #self.QTPreamble(user)

        # uses user profile to select which games to play
        self.play_games()

        # QT outro
        #self.QTPostamble()

        # Close up shop
        self.OnExit()

        # Save a copy of data, that's much easier to read for humes
        self.data_printout(self.user_data, save_to_file = True)


if __name__ == '__main__':
    game_manager = GameManager()
    game_manager.Main()





















