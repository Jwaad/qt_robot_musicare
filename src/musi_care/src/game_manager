#!/usr/bin/env python
# This code is the only node that needs to be run, instead of opening 3 different nodes before starting.

import rospy
import roslaunch
import rosnode
import pickle
import random
import pygame
import os
from musicare_lib import Renderer
from musicare_lib import Button
from musicare_lib import AnimationManager
from musicare_lib import InputBox
from musicare_lib import StandardLevels
from musicare_lib import Behaviours
from musicare_lib import General
from musicare_lib import QTManager
from musicare_lib import VolumeSlider
from guess_mood import Guess_The_Mood_Game as GTM
from fix_song import Fix_The_Song_Game as FTS
from clap_beat import Clap_To_Beat_Game as CTB
from simon_says_clap import Simon_Says_Clap_Game as SSC
import time
import glob


class GameManager():

    # On start: check if we are connected to robot and decide which nodes to run
    def __init__(self):
        # Init vars
        self.debug = True
        self.run = True
        self.path_to_music = "game_assets/music/"
        this_file_path = os.path.dirname(__file__)
        self.path_to_userdata = os.path.join(this_file_path, 'game_assets/data/user_data/')
        self.session_time = 25 * 60 # Time in seconds that sessions should last for. (Minimum time)
        self.session_name = "session_" # this should be appended with a number e.g: session_3
        self.session_data = {}
        self.games = ["GTM", "FTS", "CTB", "SSC"]
        self.prev_game = ""

        # Init ros side
        rospy.init_node('GameManager', anonymous=False)
        self.PingNode = "/qt_motor"
        self.musicarePkgName = "musi_care"
        self.jwaadTestPkgName = "jwaad_test"
        self.ActiveNodes =[] # Store reference to all nodes that we start

        # Check robot connected
        self.command_manager = QTManager(debug=self.debug) # this should happen before startrobotnodes
        self.default_voice_vol = 82
        robot_connected = self.CheckRobotRunning()
        rospy.set_param('/activity_status', 1) # Tell ros this node is starting
        if robot_connected:
            self.StartRobotNodes()
        else:
            self.StartSimulatedRobotNodes()
        self.StartLaptopNodes()

        # Init libraries / tool boxes
        self.InitPygame()
        self.animation_manager = AnimationManager(self.pygame)
        self.behaviours_manager = Behaviours(self.pygame, self.path_to_music)
        self.general_functions = General()
        self.Levels = StandardLevels(self.window, self.window_center, self.pygame, self.path_to_music, debug=self.debug)
        self.renderer = Renderer(self.window, self.window_center)

        # Set inputs to either touch or mouse
        self.input_mode = 1  # input mode 1 for touch, 2 for mouse
        if self.input_mode == 2:
            self.inputUp = self.pygame.MOUSEBUTTONUP
            self.inputDown = self.pygame.MOUSEBUTTONDOWN
            self.inputMotion = self.pygame.MOUSEMOTION
        else:
            self.inputUp = self.pygame.FINGERUP
            self.inputDown = self.pygame.FINGERDOWN
            self.inputMotion = self.pygame.FINGERMOTION

        # Hide cursor
        if not self.debug:
            self.pygame.mouse.set_visible(False)  # set to false when not testing


    def InitPygame(self):
        self.run = True
        self.pygame = pygame
        self.pygame.init()  # start py engine
        self.pygame.freetype.init()
        self.FPS = 30
        self.clock = self.pygame.time.Clock()
        os.environ['SDL_VIDEO_WINDOW_POS'] = '%d,%d' % (150, 0)  # move screen to account for toolbar
        self.window_x = 2850
        self.window_y = 2000
        # res = pygame.display.Info()  # get our screen resolution
        # self.window_x = res.current_w - 150  # Width of window -150 to account for the linux toolbar
        # self.window_y = res.current_h  # Height of window
        self.window_center = (int(self.window_x / 2), int(self.window_y / 2))
        self.cen_x = self.window_center[0]
        self.cen_y = self.window_center[1]
        self.window = pygame.display.set_mode((self.window_x, self.window_y))  # Create window and set size
        self.background_colour = (100, 100, 100)  # background Gray by default
        self.pygame.display.set_caption("MusiCare Cognitive Games with QT robot")  # Label window

    def create_button(self, file_name, location, return_info=None, scale=1.0, unique_id="", text="",
                      on_click=None, on_release=None, font_size = None):
        """code creates button using the button_image class."""
        this_file_path = os.path.dirname(__file__)
        relative_path = 'game_assets/graphics'
        file_path = os.path.join(this_file_path, relative_path, file_name)

        button = Button(file_path, location, self.pygame, return_info = return_info, scale=scale, unique_id=unique_id,
                        text=text, on_click=on_click, on_release=on_release,font_size = font_size)
        return button

    # Check if the robot is connected, by calling nodes and seeing if we get a response
    def CheckRobotRunning(self):
        rospy.loginfo("Checking if robot is connected to laptop")
        robot_connected = rosnode.rosnode_ping(self.PingNode, max_count=3)
        if robot_connected:
            rospy.loginfo("Connecting to robot and running nodes")
        else:
            rospy.loginfo("Could not detect robot, running in offline mode")
        return robot_connected

    # SSH into robot and start QT command node
    def StartRobotNodes(self):
        nodeName = 'qt_command_node'
        node = self.StartNode(self.musicarePkgName, nodeName)
        time.sleep(1)
        self.command_manager.set_voice_vol(self.default_voice_vol)
        self.ActiveNodes.append(node)

    # Start the laptop side fake node that just takes in the commands and prints them
    def StartSimulatedRobotNodes(self):
        nodeName = 'laptop_command'
        node = self.StartNode(self.jwaadTestPkgName, nodeName)
        time.sleep(1)
        self.ActiveNodes.append(node)

    # Start the sound player on laptop side
    def StartLaptopNodes(self):
        nodeName = 'sound_player'
        node = self.StartNode(self.musicarePkgName, nodeName)
        time.sleep(1)
        self.ActiveNodes.append(node)

    # Run some code before we close out of this node (Ros does this automatically, but we do it again anyways, just incase)
    def OnExit(self):
        # Save user data
        self.SaveExistingUserData()

        # End pygame
        self.pygame.quit()

        # Close all the nodes we started on launch (though this happens automatically)
        rospy.loginfo("Exiting...")
        for node in self.ActiveNodes:
            node.stop()

        rospy.set_param('/activity_status', 0)  # Tell ros this node is ended

        # END ROSCORE HERE, maybe?
        print("Ending...")


    # Start a node and store the reference to it
    def StartNode(self, nodePackage, nodeName):
        node = roslaunch.core.Node(nodePackage, nodeName)

        launch = roslaunch.scriptapi.ROSLaunch()

        launch.start()
        nodeRef = launch.launch(node)
        return nodeRef

    def LoadUserDatabase(self, run = True):
        """ Load all users into memory, so we can  """
        self.user_database = []

        if run:

            users = []
            # Get list of all users
            users = glob.glob(self.path_to_userdata + "/*.p")
            if users == []:
                return self.user_database
            for path in users:
                user_data = {}
                with open(path, "rb") as f:
                    print("attempting to open {0}".format(path))
                    user_data = pickle.load(f)
                self.user_database.append(user_data)

            # Also extract / update names, for log in screen
            self.first_names = []
            self.surnames = []
            for user in self.user_database:
                self.first_names.append(user["name"])
                self.surnames.append(user["surname"])

            return run, self.user_database

    def SaveNewUser(self, name, surname, DoB):
        """
        Save a New User to System
        name = string of first name
        surname = string of last name
        DoB = string of Date of birth in format dd-mm-yy as integers. e.g: 01-01-99
        """
        file_name = name[0] + surname[0] + DoB + ".p"

        # Format data of new user
        data = {}
        data["name"] = name # first name
        data["surname"] = surname # surnanme
        data["dob"] = DoB # dob in format dd-mm-yyyy
        data["blacklist"] = [] # songs which receive negative survey
        data["song_preference"] = {}  #
        data["game_data"] = {"difficulty": {"GTM":"easy", "FTS":"easy", "CTB":"easy", "SSC":"easy"} }

        # Get path and save
        file_path = os.path.join(self.path_to_userdata, file_name)

        # Save to file if it doesnt exist already
        if not os.path.exists(file_path):
            open(file_path, "w").close()
            with open(file_path, "wb") as f:
                pickle.dump(data, f)
            rospy.loginfo("User data saved to {0}".format(file_path))
        else:
            rospy.loginfo("User data not saved, user already exists.")
        return data

    def SaveExistingUserData(self, user=None):
        """
        Overwrite the save data of an existing user. Can specify user.
        If user is not specified will assume there's a user in memory stored in "self.user_data"
        """
        if user is None:
            user = {}
        try:
            # If user wasn't specified check if attribute user_data exists
            if user == {}:
                if len(self.user_data.keys()) < 1:
                    return user
        except:
            # User is not a dict, or doesnt exist, so just return
            return user
        # If they don't specify a user: use the user saved as attribute
        if user == {} or user is None:
            user = self.user_data

        file_name = user["name"][0] + user["surname"][0] + user["dob"] + ".p"

        # Get path and save
        file_path = os.path.join(self.path_to_userdata, file_name)

        # Save to file if it doesnt exist already
        open(file_path, "w").close()
        with open(file_path, "wb") as f:
            pickle.dump(user, f)
        rospy.loginfo("User data saved to {0}".format(file_path))
        return user

    def SignupScreen(self):

        # Input / text boxes
        name_box = InputBox(600, 300, 1000, 200, "First Name")
        surname_box = InputBox(600, 700, 1000, 200, "ParticipantID")
        dob_box = InputBox(600, 1100, 1000, 200, "nn-nn-nnnn", allowed_chars="0123456789", max_chars=10)
        inputboxes = [name_box, surname_box, dob_box]
        # Check marks
        name_tick = self.create_button("check_mark.png", (1750, 325))
        surname_tick = self.create_button("check_mark.png", (1750, 725))
        dob_tick = self.create_button("check_mark.png", (1750, 1125))
        ticks = {}
        #ticks = {1: name_tick, 2: surname_tick, 3: dob_tick}
        # Buttons
        back_button = self.create_button("tut_back.png", (20, 20))
        confirm_button = self.create_button("blank_button.png", (900, 1500), text="Done")
        buttons = [back_button, confirm_button]


        back = False
        while (not rospy.is_shutdown()) and (self.run) and not back:

            # Handle events
            for event in self.pygame.event.get():

                mouse_pos = self.pygame.mouse.get_pos()

                # Handle events for name box
                event_triggered = name_box.handle_event(event, mouse_pos)
                if event_triggered == "KEYDOWN":
                    if (name_box.get_text() is not None) and (name_box.get_text() != ""):
                        ticks["name"] = name_tick
                    else:
                        # If tick is already in our dict, remove it
                        if "name" in ticks:
                            del ticks["name"]

                # Handle events for surname box
                event_triggered = surname_box.handle_event(event, mouse_pos)
                if event_triggered == "KEYDOWN":
                    if (surname_box.get_text() is not None) and (surname_box.get_text() != ""):
                        ticks["surname"] = surname_tick
                    else:
                        if "surname" in ticks:
                            del ticks["surname"]

                # Handle events for dob box
                event_triggered = dob_box.handle_event(event, mouse_pos)
                if event_triggered == "KEYDOWN":
                    # Add the - at set intervals
                    if event.key != pygame.K_BACKSPACE:
                        if len(dob_box.get_text()) in [2, 5]:
                            dob_box.text += "-"
                    # If backspace over a "-", then take additional char
                    else:
                        if len(dob_box.get_text()) in [3, 6]:
                            dob_box.text = dob_box.text[:-1]
                    # Check length is correct for dob:
                    if len(dob_box.get_text()) == 10:
                        ticks["dob"] = dob_tick
                    else:
                        if "dob" in ticks:
                            del ticks["dob"]

                # Check back button and done button
                back = back_button.get_event(event, mouse_pos)
                done_clicked = confirm_button.get_event(event, mouse_pos)

                # Check "Done"
                if len(ticks.values()) == 3:
                    if done_clicked:
                        new_user = self.SaveNewUser(name_box.get_text(), surname_box.get_text(), dob_box.get_text())
                        self.LoadUserDatabase()
                        back = True
                        print(new_user)

                # Handle on click animation
                if event.type == self.inputUp:  # On mouse release play animation to show where cursor is
                    self.animation_manager.StartTouchAnimation(mouse_pos)  # Play animation

                # Check quit
                if event.type == pygame.QUIT:
                    self.run = False
                    print("Quitting...")

            # Draw background
            self.renderer.DrawBackground(self.background_colour)

            # Update graphics
            for button in buttons:
                button.render(self.window)
            for box in inputboxes:
                box.render(self.window)
            if len(ticks.values()) > 0:
                for tick in ticks.values():
                    tick.render(self.window)
            self.animation_manager.DrawTouchAnimation(self.window)
            self.pygame.display.update()  # Update all drawn objects

            # Cap FPS (save resources)
            self.clock.tick(self.FPS)

    def voice_test(self):
        print("Playing voice")
        sayings = ["Hello, can you hear me?",
                   "Can you hear me now?",
                   "Hi! Is this volume okay?",
                   "Mike test 1, 2. 1, 2."
                   ]
        ind = random.randint(0, len(sayings) - 1)
        message = sayings[ind]

        self.command_manager.qt_say(message)

    def LogInScreen(self, run = True):
        """
        Use database, and check if user is inputting credentials we have seen before.
        Once a user is logged in, this method also sets "self.session_name" to the current number.
        """

        # Input / text boxes
        name_box = InputBox(200, 600, 1000, 200, "Name")
        surname_box = InputBox(1600, 600, 1000, 200, "ParticipantID")
        inputboxes = [name_box, surname_box]
        # Check marks
        name_tick = self.create_button("check_mark.png", (650, 800))
        surname_tick = self.create_button("check_mark.png", (2050, 800))
        ticks = {}

        # Volume Slider
        voice_slider = VolumeSlider(self.pygame, (50, 75), scale=1.5, min_val=50,
                                    default_vol=self.default_voice_vol,
                                    on_release=self.command_manager.set_voice_vol)

        # Buttons
        next_button = self.create_button("next_button.png", (1100, 1200))
        signup_button = self.create_button("blank_button.png", (2300, 20), text="New User", scale=0.5)
        text_voice_button = self.create_button("QT_volume_icon.png", (45, voice_slider.slider_box_rect[1] + voice_slider.slider_box_rect[3] + 50  ),
                                               scale=1.2, on_click=self.voice_test)

        log_in = False
        user_recognised = False
        correct_surname = "#}$"
        while (not rospy.is_shutdown()) and run and not log_in:


            for event in self.pygame.event.get():
                # Handle events
                mouse_pos = self.pygame.mouse.get_pos()
                #print("event")

                # Handle on click animation
                if event.type == self.inputUp:  # On mouse release play animation to show where cursor is
                    self.animation_manager.StartTouchAnimation(mouse_pos)  # Play animation

                # Handle events for name box
                event_triggered = name_box.handle_event(event, mouse_pos)
                if event_triggered == "KEYDOWN":
                    if name_box.get_text() in self.first_names:
                        ticks["name"] = name_tick
                        # Get the corresponding surname
                        ind = self.first_names.index(name_box.get_text())
                        correct_surname = self.surnames[ind]
                    else:
                        # If tick is already in our dict, remove it
                        if "name" in ticks:
                            del ticks["name"]
                            user_recognised = False
                            correct_surname = "#}$"

                # Handle events for surname box
                event_triggered = surname_box.handle_event(event, mouse_pos)
                if event_triggered == "KEYDOWN":
                    if surname_box.get_text() == correct_surname:
                        ticks["surname"] = surname_tick
                        user_recognised = True
                    else:
                        # If tick is already in our dict, remove it
                        if "surname" in ticks:
                            del ticks["surname"]
                            user_recognised = False
                            correct_surname = "#}$"

                # Handle event for next button
                next_clicked = next_button.get_event(event, mouse_pos)
                if next_clicked:
                    if user_recognised:
                        self.user_data = self.user_database[self.surnames.index(surname_box.get_text())]
                        log_in = True

                # Handle event for volume slider
                voice_slider.handle_event(event, mouse_pos)
                text_voice_button.get_event(event, mouse_pos)

                # Handle event for new user
                signup = signup_button.get_event(event, mouse_pos)
                if signup:
                    self.SignupScreen()

                # Check quit
                if event.type == pygame.QUIT:
                    run = False
                    print("Quitting...")
                    # If user data doesnt exist, return empty list instead
                    try:
                        len(self.user_data)
                    except:
                        return False, {}
                    return False, self.user_data

            # Draw background
            self.renderer.DrawBackground(self.background_colour)

            # Update graphics
            for box in inputboxes:
                box.render(self.window)
            if len(ticks.values()) > 0:
                for tick in ticks.values():
                    tick.render(self.window)
            next_button.render(self.window)
            signup_button.render(self.window)
            voice_slider.render(self.window)
            text_voice_button.render(self.window)
            self.animation_manager.DrawTouchAnimation(self.window)
            self.pygame.display.update()  # Update all drawn objects

            # Cap FPS (save resources)
            self.clock.tick(self.FPS)

        # Get what session this is
        self.count_session()

        return run, self.user_data

    def mood_comment_post(self, mood_rating, prev_mood):
        """ Using the mood of the user, robot should say something"""
        # max_mood = 5 # the highest and happiest score possible.
        neutral_rating = 3

        # Positive rating, pre and post. (mood stayed same positive)
        if mood_rating > neutral_rating and prev_mood > neutral_rating:
            # "Thats good" type message
            sayings = ["I'm very happy that you're still happy",
                       "Thats great news!",
                       "That's so good to hear!",
                       "Wonderful!",
                       "That makes me happy too"
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = "arms_up"
        # Positive rating post, but not pre. (mood went up)
        elif mood_rating > neutral_rating and prev_mood < neutral_rating:
            # "Thats good" type message
            sayings = ["Really? Thats such good news !",
                       "Wow, so you're happier than before? then im happy too !"
                       "Yay! You feel a bit more cheerful than earlier. Thats so good!",
                       "Hurray, im so happy to hear you're not feeling down"
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = "arms_up"
        # Negative rating post, but not pre. (Mood went down)
        elif mood_rating < neutral_rating and prev_mood > neutral_rating:
            # "That's too bad" type message
            sayings = ["Oh... Thats too bad. I'm sorry about that... Maybe next time will be more fun",
                       "Aww, maybe next time will be a bit more fun...",
                       "Thats a shame, i hope you feel more cheerful."
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = "shake_head"
        # negative rating, pre and post. (mood stayed same negative)
        elif mood_rating < neutral_rating and prev_mood < neutral_rating:
            # "Thats good" type message
            sayings = ["Hopefully your mood improves throughout the day.",
                       "I wish i could chat longer, to make you feel more cheerful...",
                       "Thats a shame, i hope you feel more cheerful later on."
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = "shake_head"
        # todo:add (neutral -> positive), (neutral -> negative), (neutral -> neutral), (positive -> neutral), (negative -> neutral)
        # todo: or just change it to (if mood_rating > prev_rating)
        # Neutral rating pre and post, + (other circumstance i missed in the logic)
        else:
            # "oh? lets fix that" type message
            sayings = ["I see, well atleast thats better than being sad!",
                       "I was hoping to make you smile more. But it's okay haha",
                       "Hope you feel more cheerful later!"
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = ""

        if gesture == "":
            self.Levels.QTSpeakingScreen(message, self.run, self.background_colour)
        else:
            self.Levels.QTSpeakingScreen(message, self.run, self.background_colour, should_gesture=True,
                                         gesture=gesture)

    def mood_comment_pre(self, mood_rating):
        """ Using the mood of the user, robot should say something"""
        # max_mood = 5 # the highest and happiest score possible.
        neutral_rating = 3

        # Positive rating
        if mood_rating > neutral_rating:
            # "Thats good" type message
            sayings = ["Thats great news! Then lets get straight into playing!",
                       "I'm so happy to hear that! Then.. lets play some games and have some fun!",
                       "Thats perfect! Then we will enjoy the games even more!",
                       "That makes me happy too! We're going to have so much fun playing these games!"
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = "arms_up"
        # Negative rating
        elif mood_rating < neutral_rating:
            # "That's too bad" type message
            sayings = ["Oh... Thats too bad. Hopefully playing games will cheer you up!",
                       "Oh... Thats too bad. Maybe playing with me can help a bit!",
                       "I'm sorry to hear. Lets play some games! maybe that will make you feel happier",
                       "Maybe playing these games will make you feel more cheerful!",
                       "Oh no! Then, in that case. Hopefully i can cheer you up with the games we'll play!"
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = "shake_head"
        # Neutral rating
        else:
            # "oh? lets fix that" type message
            sayings = ["Hmm, okay maybe playing games will make you feel livey!",
                       "Oh, okay. Then lets play games. Maybe you'll feel cheerful after!",
                       "okay. Then... Lets play some games. It might make you feel happy!"
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = ""

        if gesture == "":
            self.Levels.QTSpeakingScreen(message, self.run, self.background_colour)
        else:
            self.Levels.QTSpeakingScreen(message, self.run, self.background_colour, should_gesture=True,
                                     gesture=gesture)

    def count_session(self):
        """
        Loop through data and figure out what session we're in
        this sets self.session_name.
        e.g: loop through data, and find there's 4 keys with string "session" in them.
        then set session_name to session_5
        """
        # Count how many sessions user has had, and add 1
        game_data = self.user_data["game_data"]
        session_num = 1 #start at 1, so we always 1 more than sessions total
        for key in game_data.keys():
            if "session_" in key:
                session_num += 1

        self.session_name += str(session_num)
        return session_num

    def count_games(self):
        """
        Method to return the correct string to save game data under.
        Read current user data and returns a string of the next game_num
        """
        if self.session_name not in self.user_data["game_data"].keys():
            return "game_1"
        session_data = self.user_data["game_data"][self.session_name]

        num_games = 1 # start at 1, to add 1 to result
        for key in session_data.keys():
            if "game_" in key:  # All keys in session should contain "game_", but just in case i add more later
                num_games += 1

        return "game_" + str(num_games)

    def get_latest_data(self, session_name = "", game_name = ""):
        """
        Loop through a given session, and retreive data of most recent game. Can specify a game type.
        Must be called after a user is already loaded into memory and stored in self.user_data
        session_name = string, should be the name of a previous session. if no name is given, then uses current session
            (self.session_name)
        game_name = string, if no game is given, returns the latest game of any type
        If no prior level data exists, then return None
        """
        if session_name == "" or session_name == None:
            session_name = self.session_name

        if session_name not in self.user_data["game_data"].keys():
            print("GLD: session data not found")
            return None

        session_data = self.user_data["game_data"][session_name]

        lastest_game = -10
        if len(session_data.keys()) > 0:
            for key in session_data.keys():
                if "game_" in key: # All keys in session should contain "game_", but just in case i add more later
                    split_key = key.split("_")
                    game_num = int(split_key[1]) # convert the number after the "_" into an int
                    # If no game_name specified, just use int
                    if game_name == "" or game_name == None:
                        if game_num > lastest_game:
                            lastest_game = game_num
                    else:
                        # otherwise, only compare if they're the same game type
                        if session_data[key]["game_name"] == game_name:
                            #print("Prev game found")
                            if game_num > lastest_game:
                                lastest_game = game_num
        # if no level data, or no specific game data return None
        if lastest_game < 1:
            print("GLD: No previous games found in session")
            return None
        level_name = "game_" + str(lastest_game)
        level_data = self.user_data["game_data"][session_name][level_name]
        return level_data

    def QTPreamble(self, user = None, run = True):
        if run:
            name = user["name"]

            # If this is a new user act differently
            if self.session_name == "session_1":
                s_1 = "Hi {}! It's so nice to meet you!... My name is QT robot.".format(name)
                s_2 = "Unfortunately. I can not understand human language..."
                s_3 = "If you want to interact with me, you will need to use the screen."
                s_4 = "Anyways!"

                dialogue = [s_1, s_2, s_3, s_4]
                gestures = ["wave", "shake_head", "explain_right", "" ]
                for i in range(0, len(dialogue)):
                    if gestures[i] == "":
                        run = self.Levels.QTSpeakingScreen(dialogue[i], run, self.background_colour)
                    else:
                        run = self.Levels.QTSpeakingScreen(dialogue[i], run, self.background_colour, should_gesture = True,
                                                     gesture = gestures[i])
                    time.sleep(1) # Add 1s delay between sentences
            else:
                # Use a randomised greeting
                run = self.Levels.QTSpeakingScreen(self.behaviours_manager.get_greetings(), self.run, self.background_colour, should_gesture=True,
                                             gesture="wave")

            # Ask user how they are, save to data
            run, mood_score = self.Levels.how_are_you(run = run, background_colour= self.background_colour)
            self.user_data["game_data"][self.session_name]["mood_pre"] = mood_score
            self.SaveExistingUserData()
            self.mood_comment_pre(mood_score) # QT should comment based on their mood e.g: "Oh, hopefully these games cheer you up"

            # introduce the start of the games
            run = self.Levels.QTSpeakingScreen(self.behaviours_manager.get_start_games(), run, self.background_colour)
        return run

    def QTPostamble(self, user = None, run = True):
        """
        Handle QT behaviour post session
        """

        if run:
            if user is None:
                user = self.user_data
            name = user["name"]

            # Say something like "this was fun"
            run = self.Levels.QTSpeakingScreen(self.behaviours_manager.get_closing_remark(), self.run, self.background_colour, should_gesture=True,
                                         gesture="arms_up")
            # Say something like "i know i asked before, but"
            run = self.Levels.QTSpeakingScreen(self.behaviours_manager.get_transition_to_question(), self.run, self.background_colour)

            # Ask user how they are, save to data
            run, mood_score = self.Levels.how_are_you(run=run, background_colour=self.background_colour,
                                                      on_screen_text= "How are you feeling now")
            self.user_data["game_data"][self.session_name]["mood_post"] = mood_score
            self.SaveExistingUserData()
            prev_mood = self.user_data["game_data"][self.session_name]["mood_pre"]
            self.mood_comment_post(mood_score, prev_mood) # comment based on mood change

            # Use a randomised greeting
            self.Levels.QTSpeakingScreen(self.behaviours_manager.get_goodbye(), self.run, self.background_colour,
                                         should_gesture=True, gesture="wave")
        return run

    def change_difficulty(self, game_name, clear_type):
        """
        Takes in game name and clear type, then checks through current user data,
        to check if user should move up or down in difficulty or that game type
        2 E_clears in a row = move up
        2 fails in a row = move down
        2 clears in a row = do nothing
        This must be called before the latest game data was saved, or it will compare itself to itself

        game_name = string, GTM, FTS, CTB, SSC
        clear_type = string, e_clear, clear, fail
        """

        # Get the data of the previous game played, in this session
        prev_game = self.get_latest_data(game_name = game_name)

        # Guard statement #1
        if prev_game is None:
            #print("no previous game data, skipping")
            return

        # Guard statement #2
        prev_clear = prev_game["clear_type"]
        if prev_clear != clear_type:
            return

        # Increase or decrease difficulty
        current_difficulty = self.user_data["game_data"]["difficulty"][game_name]
        if clear_type == "clear":
            return
        elif clear_type == "fail":
            if current_difficulty == "easy":
                print("difficulty already at lowest")
                return # if we cant get any easier, just return
            print("decreasing difficulty")
            if current_difficulty == "medium":
                self.user_data["game_data"]["difficulty"][game_name] = "easy"
            elif current_difficulty == "hard":
                self.user_data["game_data"]["difficulty"][game_name] = "medium"
            return
        elif clear_type == "e_clear":
            if current_difficulty == "hard":
                print("difficulty already at highest")
                return # if we cant get any harder, just return
            print("increasing difficulty")
            if current_difficulty == "medium":
                self.user_data["game_data"]["difficulty"][game_name] = "hard"
            elif current_difficulty == "easy":
                self.user_data["game_data"]["difficulty"][game_name] = "medium"
            # QT congratulatory message
            self.Levels.QTSpeakingScreen(self.behaviours_manager.get_next_difficulty(), self.run, self.background_colour,
                                         should_gesture=True,
                                         gesture="arms_up")
            return

    def home_screen(self, run = True):
        """A initial screen for the games where users can select a level to start with."""

        # Create buttons for each game
        GTM_button = self.create_button("blank_button.png", (850, 200), text="Guess The Mood",
                                        scale=1.2, return_info="GTM", font_size=40)
        FTS_button = self.create_button("blank_button.png", (850, 600), text="Fix The Song",
                                        scale=1.2, return_info="FTS", font_size=40)
        CTB_button = self.create_button("blank_button.png", (850, 1000), text="Clap to The Beat",
                                        scale=1.2, return_info="CTB", font_size=40)
        SSC_button = self.create_button("blank_button.png", (850, 1400), text="Simon Says Clap",
                                        scale=1.2, return_info="SSC", font_size=40)
        buttons = [GTM_button, FTS_button, CTB_button, SSC_button]

        # Add on display icons to each of the buttons
        GTM_icon = self.create_button("GTM_icon.png", (550, 250), scale = 0.5)
        CTB_icon = self.create_button("CTB_icon.png", (575, 650), scale = 1.3)
        FTS_icon = self.create_button(""
                                      "FTS_icon.png", (550, 1075), scale = 0.5)
        SSC_icon = self.create_button("SSC_icon.png", (550, 1475), scale = 0.5)
        icons =  [GTM_icon, FTS_icon, CTB_icon, SSC_icon]

        game_selected = False
        self.run = run
        while self.run and not game_selected:

            # Handle events
            for event in self.pygame.event.get():
                mouse_pos = self.pygame.mouse.get_pos()
                # Handle game button events
                for button in buttons:
                    pressed = button.get_event(event, mouse_pos)
                    if pressed:
                        print(button.get_info())
                        game_selected = True
                # Handle on click animation
                if event.type == self.inputUp:  # On mouse release play animation to show where cursor is
                    self.animation_manager.StartTouchAnimation(mouse_pos)  # Play animation

                # Check quit
                if event.type == pygame.QUIT:
                    self.run = False
                    print("Quitting...")

            # Render Graphics
            self.renderer.DrawBackground(self.background_colour)
            for button in buttons:
                button.render(self.window)
            for icon in icons:
                icon.render(self.window)
            self.animation_manager.DrawTouchAnimation(self.window)  # Also draw touches
            self.pygame.display.update()  # Update all drawn objects

        return self.run


    def play_games(self, run = True):
        """
        semi-randomly selects a game to play, from those added into "self.games"
        randomly selects from the games that have been played least.
        Also increases or decreases difficulty as needed and saves user data after each level
        """
        # Populate a list of counters for each game type
        this_session = []
        for game in self.games:
            this_session.append(0)

        play_time = 0
        time_start = rospy.get_time()
        game_num = 0
        # Keep selecting games to be played until full time has passed
        while play_time < (self.session_time) and run:
            # Keep track of what how many games we've played.
            game_num += 1

            # Populate new list of the games which have been played the least, and randomly select from that list
            min_value = min(this_session)
            selectable_games = []
            for i, x in enumerate(this_session):
                if x == min_value:
                    selectable_games.append(i)
            if len(selectable_games) == 1:
                selected_game_ind =  selectable_games[0]
            else:
                selected_game_ind = random.choice(selectable_games)
            game_name = self.games[selected_game_ind]
            this_session[selected_game_ind] += 1

            # Get difficulty from user profile
            difficulty = self.user_data["game_data"]["difficulty"][game_name]
            play_tut = False
            if difficulty == "easy":
                play_tut = True

            # Play game
            run, user_level_data = self.play_game(game_name, difficulty, play_tut)

            # Check if difficulty should increase or decrease
            clear_type = user_level_data["clear_type"]
            self.change_difficulty(game_name, clear_type)

            # Add user_level_data to data and save
            game_save_name = "game_" + str(game_num)
            self.user_data["game_data"][self.session_name][game_save_name] = user_level_data
            self.SaveExistingUserData()

            # Ask if they liked the song (if we haven't asked about this song before)
            song_title = user_level_data["song_title"]
            if song_title not in self.user_data["song_preference"]:
                run, song_rating = self.Levels.did_you_like_song(run = self.run, background_colour= self.background_colour)
                self.user_data["song_preference"][song_title] = song_rating
                # If negative score, black_list song
                if song_rating < 3 :
                    self.user_data["blacklist"].append(song_title)
                self.SaveExistingUserData()

            # update play time
            play_time = rospy.get_time() - time_start

        return run

    def get_random_song(self,game_name, difficulty, run = True, song_to_skip = None):
        """
        Gets random song from database depending on designated song name and difficulty inputted.
        Checks user black lists and the previous song, and keeps randomising until a applicable song is selected.
        If there is not applicable one, a random one is returned.

        game_name = string, GTM, FTS, CTB, SSC
        difficulty = string, easy, medium, hard
        run = bool, entering false will skip the entire method. Allows quiting mid game
        """
        if run :
            # Load data for selected game
            song_data = self.general_functions.Load_Song_Data(game_name)

            # make copy of databse so we can pop it
            levels = song_data[difficulty].copy()

            # Pop a specific song out of our dict
            if song_to_skip is not None:
                if len(levels.keys()) > 1:
                    levels.pop(song_to_skip)

            # Pop the previous song from this list, to prevent repetition
            prev_level = self.get_latest_data(game_name=game_name)
            if prev_level is not None:
                if prev_level["difficulty"] == difficulty:  # prevents key error (dont pop an easy song from the med list)
                    if len(levels.keys()) > 1:
                        levels.pop(prev_level["song_title"])

            # Choose random song from selected difficulty
            i = random.randint(0, len(levels) - 1)  # choose random one
            song_title = list(levels.keys())[i]  # There's only 1 key, and it's the songs title
            # Keep randomising til we play a non-blacklisted song
            while song_title in self.user_data["blacklist"]:
                i = random.randint(0, len(levels.keys()) - 1)  # choose random one
                song_title = list(levels.keys())[i]  # There's only 1 key, and it's the songs title
                levels.pop(song_title)  # remove song from level data, and re randomise
                # If we've popped out all songs, just use the last 1 left
                if len(levels) < 1:
                    print("All {} {} songs are black listed, using random one".format(difficulty, game_name))
                    break

            level_data = song_data[difficulty][song_title]
            return run, level_data, song_title

    def play_game(self, game_name, difficulty, play_tut, run = True):
        """
        Method to load and launch specified game at specified difficulty
        game_name = string, GTM, FTS, CTB, SSC
        difficulty = string, tut, easy, medium, hard
        play_tut = bool, whether or not the game should ask if tut should be shown
        """
        user_level_data = {}
        self.run = run
        if self.run:

            # Choose random song
            self.run, level_data, song_title = self.get_random_song(game_name, difficulty)
            file_name = level_data["file_name"]

            # Play GTM
            if game_name == "GTM":

                # Init game
                game = GTM(debug=self.debug, screen= self.window)

                # get game specific parameters
                mood = level_data["mood"]

                # Play game
                self.run, user_level_data = game.Main(mood, file_name, ask_tut = play_tut)
            # Play FTS
            elif game_name == "FTS":
                # Init game
                game = FTS(debug=self.debug, screen= self.window)

                if difficulty == "easy":
                    distract_song = None
                    slices = 2 # cut song into 2 parts
                elif difficulty == "medium":
                    # get another random song, that isn't the current one
                    self.run, distract_song_data, song_title = self.get_random_song(game_name, difficulty, song_to_skip = song_title)
                    distract_song = distract_song_data["file_name"]
                    slices = 2
                else:
                    # get another random song, that isn't the current one
                    self.run, distract_song_data, song_title = self.get_random_song(game_name, difficulty, song_to_skip=song_title)
                    distract_song = distract_song_data["file_name"]
                    slices = 3  # cut song into 3 parts
                    # TODO add 4 slices here. Currently game isn't compatible with 4 slices

                # Play game
                self.run, user_level_data = game.Main(file_name, distract_song, slices, ask_tut = play_tut)
            # Play CTB and SSC
            else:
                # Put arms up and wait for drum
                self.Levels.get_drum(run = self.run,background_colour=self.background_colour)

                # Shared vars between SSC and CTB
                first_beat = level_data["first_beat"]
                bpm = level_data["bpm"]

                if game_name == "CTB" :
                    # Init game
                    game = CTB(debug=self.debug, screen= self.window)

                    # Play game
                    self.run, user_level_data = game.Main(file_name, first_beat, bpm, ask_tut = play_tut)
                else:
                    # Init game
                    game = SSC(debug=self.debug, screen= self.window)

                    # Play game
                    self.run, user_level_data = game.Main(file_name, first_beat, bpm, ask_tut = play_tut)

                # After game finishes, remove drum, even if we're bout to play ctb from ssc
                self.Levels.put_away_drum(run=self.run, background_colour=self.background_colour)

            # Append data with title and difficulty
            user_level_data["song_title"] = song_title
            user_level_data["difficulty"] = difficulty
            self.prev_game = game_name
        return self.run, user_level_data

    def data_printout(self, user, save_to_file = False):
        """
        Print out the data of the user in a nice formatted string
        Recursively loops through dicts in the dict, and adds indentation
        """
        try:
            # If user wasn't specified check if attribute user_data exists
            if user == {}:
                if len(self.user_data.keys()) < 1:
                    return user
        except:
            # User is not a dict, or doesnt exist, so just return
            return user

        def add_data_to_string(mydict, string_data, loop_num):
            indent = (loop_num * "    ")
            for key in mydict.keys():
                if type(mydict[key]) == dict:
                    string_data += indent + str(key) + ":\n"
                    string_data = add_data_to_string(mydict[key], string_data, loop_num + 1) # ITS REWIND TIME
                elif type(mydict[key]) == list:
                    string_data += indent + str(key) + ": " + str(mydict[key]) + "\n"
                else:
                    string_data += indent + str(key) + ": " +  str(mydict[key]) + "\n"
            return string_data

        data = ""
        data = add_data_to_string(user, data, 0)

        if save_to_file:
            file_name = user["name"][0] + user["surname"][0] + user["dob"] + "_Readout.txt"
            file_path = os.path.join(self.path_to_userdata, file_name)

            with open(file_path, "w") as text_file:
                text_file.write(data)
            rospy.loginfo("Formatted readout, saved to {0}".format(file_path))
        else:
            print()
            print(data)

    def bypass_login(self):
        """For debugging, load straight into games"""
        self.user_data = self.user_database[0]
        self.count_session()
        if self.run:
            self.user_data["game_data"][self.session_name] = {}


    # Create GUI to control which level to play
    def Main(self):

        # Load all users into memory
        self.run, self.user_database = self.LoadUserDatabase(run = self.run)
        if self.debug:
            print("Finished loading database")

        # use name and surname to get user data
        self.run, self.user_data = self.LogInScreen(run = self.run)
        if self.debug:
            print("Finished logging in")

        # Init the session
        if self.run:
            self.user_data["game_data"][self.session_name] = {}

        # What QT should say to the returning or new user
        self.run = self.QTPreamble(user = self.user_data, run = self.run)
        if self.debug:
            print("Finished preamble screen")

        # Choose starting game
        self.run = self.home_screen(run = self.run)

        # uses user profile to select which games to play
        #self.run = self.play_games(run = self.run)


        # QT outro
        self.run = self.QTPostamble(user = self.user_data, run = self.run)

        # Close up shop
        self.OnExit()

        # Save a copy of data, that's much easier to read for humes
        self.data_printout(self.user_data, save_to_file = True)


if __name__ == '__main__':
    game_manager = GameManager()
    #game_manager.Main()
    game_manager.home_screen()





















