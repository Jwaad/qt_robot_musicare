#!/usr/bin/env python
# This code is the only node that needs to be run, instead of opening 3 different nodes before starting.

import rospy
import roslaunch
import rosnode
#import paramiko # For SSH
import pygame
import os
from musicare_lib import Renderer
from musicare_lib import Button
from musicare_lib import AnimationManager
import time

class GameManager():

    # On start: check if we are connected to robot and decide which nodes to run
    def __init__(self):
        rospy.init_node('GameManager', anonymous=False)
        self.PingNode = "/PLACEHOLDER FOR QT MOTOR CONTROLLER TOPIC"
        self.musicarePkgName = 'musi_care'
        self.jwaadTestPkgName = "jwaad_test"
        self.ActiveNodes =[] # Store reference to all nodes that we start
        robot_connected = self.CheckRobotRunning()
        rospy.set_param('/activity_status', 1) # Tell ros this node is startingariables
    def InitPygame(self):
        self.run = True
        self.pygame = pygame
        self.pygame.init()  # start py engine
        self.pygame.freetype.init()
        self.FPS = 30
        self.clock = self.pygame.time.Clock()
        res = pygame.display.Info()  # get our screen resolution
        self.window_x = 2850
        self.window_y = 2000
        #self.window_x = res.current_w - 150  # Width of window -150 to account for the linux toolbar
        #self.window_y = res.current_h  # Height of window
        self.window_center = (int(self.window_x / 2), int(self.window_y / 2))
        self.cen_x = self.window_center[0]
        self.cen_y = self.window_center[1]
        self.window = pygame.display.set_mode((self.window_x, self.window_y))  # Create window and set size
        self.background_colour = (100, 100, 100)  # background Gray by default
        self.pygame.display.set_caption("Game Selector")  # Label window
        self.renderer = Renderer(self.window, self.window_center)

    def create_button(self, file_name, location, return_info = {}, scale=1, unique_id="", text = ""):
        """code creates button using the button_image class."""
        this_file_path = os.path.dirname(__file__)
        relative_path = 'game_assets/graphics'
        file_path = os.path.join(this_file_path, relative_path, file_name)

        if robot_connected:
            self.StartRobotNodes()
        else:
            self.StartSimulatedRobotNodes()
        self.StartLaptopNodes()
        self.InitPygame()
        self.run = True
        self.animation_manager = AnimationManager(self.pygame)

    # Set screen and game related v
        button = Button(file_path, location, self.pygame, return_info = {}, scale=scale, unique_id=unique_id, text=text)
        return (button)

    def CreateGameButtons(self):
        blankButton = "blank_button.png"
        guessMoodButton = self.create_button(blankButton, (100,200), return_info = {}, text = "Guess The Mood")
        testButton =  self.create_button(blankButton, (100,600), return_info = {}, text = "Fix The Song")
        return [guessMoodButton, testButton]

    # Create GUI to control which level to play
    def Main(self):
        fps = "999"

        buttons = self.CreateGameButtons()
        while (not rospy.is_shutdown()) and (self.run):
            t1 = time.time()

            mouse_pos = self.pygame.mouse.get_pos()

            # Handle events
            for event in self.pygame.event.get():

                # Handle on click animation
                if event.type == self.pygame.MOUSEBUTTONUP:  # On mouse release play animation to show where cursor is
                    self.animation_manager.StartTouchAnimation(mouse_pos)  # Play animation

                # Handle game selector buttons
                for button in buttons:
                    button.get_event(event, mouse_pos=mouse_pos)

                # Check quit
                if event.type == pygame.QUIT:
                    self.run = False
                    print("Quitting...")

            # Draw background
            self.renderer.DrawBackground(self.background_colour)

            # Draw fps
            self.renderer.DrawText(fps, (2800,25), 50)

            # Update graphics
            for button in buttons:
                button.render(self.window)
            self.animation_manager.DrawTouchAnimation(self.window)
            self.pygame.display.update()  # Update all drawn objects

            # Cap FPS (save resources)
            self.clock.tick(self.FPS)
            fps = str(round(1 / (time.time() - t1)))

        self.OnExit()
        print("Ending...")

    # Check if the robot is connected, by calling nodes and seeing if we get a response
    def CheckRobotRunning(self):
        rospy.loginfo("Checking if robot is connected to laptop")
        robot_connected = rosnode.rosnode_ping(self.PingNode, max_count=3)
        if robot_connected:
            rospy.loginfo("Connecting to robot and running nodes")
        else:
            rospy.loginfo("Could not detect robot, running in offline mode")
        return robot_connected

    # SSH into robot and start QT command node
    def StartRobotNodes(self):
        time.sleep(1)
        # TODO ADD SSH INTO ROBO AND START SERVER HERE

    # Start the laptop side fake node that just takes in the commands and prints them
    def StartSimulatedRobotNodes(self):
        nodeName = 'laptop_command'
        node = self.StartNode(self.jwaadTestPkgName, nodeName)
        time.sleep(1)
        self.ActiveNodes.append(node)

    # Start the sound player on laptop side
    def StartLaptopNodes(self):
        nodeName = 'sound_player'
        node = self.StartNode(self.musicarePkgName, nodeName)
        time.sleep(1)
        self.ActiveNodes.append(node)

    # Run some code before we close out of this node (Ros does this automatically, but we do it again anyways, just incase)
    def OnExit(self):
        # End pygame
        self.pygame.quit()

        # Close all the nodes we started on launch (though this happens automatically)
        rospy.loginfo("Exiting...")
        for node in self.ActiveNodes:
            node.stop()

    # Start a node and store the reference to it
    def StartNode(self, nodePackage, nodeName):
        node = roslaunch.core.Node(nodePackage, nodeName)

        launch = roslaunch.scriptapi.ROSLaunch()

        launch.start()
        nodeRef = launch.launch(node)
        return nodeRef

if __name__ == '__main__':
    game_manager = GameManager()
    game_manager.Main()