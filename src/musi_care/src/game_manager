#!/usr/bin/env python
# This code is the only node that needs to be run, instead of opening 3 different nodes before starting.

import rospy
import roslaunch
import rosnode
import pickle
import random
import pygame
import os
from musicare_lib import Renderer
from musicare_lib import Button
from musicare_lib import AnimationManager
from musicare_lib import InputBox
from musicare_lib import StandardLevels
from musicare_lib import Behaviours
import time
import glob

class GameManager():

    # On start: check if we are connected to robot and decide which nodes to run
    def __init__(self):
        rospy.init_node('GameManager', anonymous=False)
        self.PingNode = "/qt_motor"
        self.musicarePkgName = "musi_care"
        self.jwaadTestPkgName = "jwaad_test"
        self.ActiveNodes =[] # Store reference to all nodes that we start
        robot_connected = self.CheckRobotRunning()
        rospy.set_param('/activity_status', 1) # Tell ros this node is starting
        if robot_connected:
            self.StartRobotNodes()
        else:
            self.StartSimulatedRobotNodes()
        self.StartLaptopNodes()
        self.InitPygame()
        self.run = True
        self.path_to_music = "game_assets/music/"
        self.animation_manager = AnimationManager(self.pygame)
        self.behaviours_manager = Behaviours(self.pygame, self.path_to_music)
        self.Levels = StandardLevels(self.window, self.window_center, self.pygame, self.path_to_music)
        this_file_path = os.path.dirname(__file__)
        self.path_to_userdata = os.path.join(this_file_path, 'game_assets/data/user_data/')
        self.session_time = 15 # Time in minutes that sessions should last for. (this is the Min time)
        self.session_data = {}


    def InitPygame(self):
        self.run = True
        self.pygame = pygame
        self.pygame.init()  # start py engine
        self.pygame.freetype.init()
        self.FPS = 30
        self.clock = self.pygame.time.Clock()
        res = pygame.display.Info()  # get our screen resolution
        self.window_x = 2850
        self.window_y = 2000
        #self.window_x = res.current_w - 150  # Width of window -150 to account for the linux toolbar
        #self.window_y = res.current_h  # Height of window
        self.window_center = (int(self.window_x / 2), int(self.window_y / 2))
        self.cen_x = self.window_center[0]
        self.cen_y = self.window_center[1]
        self.window = pygame.display.set_mode((self.window_x, self.window_y))  # Create window and set size
        self.background_colour = (100, 100, 100)  # background Gray by default
        self.pygame.display.set_caption("Game Selector")  # Label window
        self.renderer = Renderer(self.window, self.window_center)

    def create_button(self, file_name, location, return_info=None, scale=1.0, unique_id="", text="",
                      on_click=None, on_release=None):
        """code creates button using the button_image class."""
        if return_info is None:
            return_info = {}
        this_file_path = os.path.dirname(__file__)
        relative_path = 'game_assets/graphics'
        file_path = os.path.join(this_file_path, relative_path, file_name)

        button = Button(file_path, location, self.pygame, return_info = {}, scale=scale, unique_id=unique_id,
                        text=text, on_click=on_click, on_release=on_release)
        return button

    def CreateGameButtons(self):
        """Archived"""
        def temp():
            print("text")

        blank_button = "blank_button.png"
        guess_mood_button = self.create_button(blank_button, (100, 200), return_info={}, text="Guess The Mood",
                                               on_click=temp)
        fix_song_button = self.create_button(blank_button, (100, 600), return_info={}, text="Fix The Song")
        return [guess_mood_button, fix_song_button]

    # Check if the robot is connected, by calling nodes and seeing if we get a response
    def CheckRobotRunning(self):
        rospy.loginfo("Checking if robot is connected to laptop")
        robot_connected = rosnode.rosnode_ping(self.PingNode, max_count=3)
        if robot_connected:
            rospy.loginfo("Connecting to robot and running nodes")
        else:
            rospy.loginfo("Could not detect robot, running in offline mode")
        return robot_connected

    # SSH into robot and start QT command node
    def StartRobotNodes(self):
        nodeName = 'qt_command_node'
        node = self.StartNode(self.musicarePkgName, nodeName)
        time.sleep(1)
        self.ActiveNodes.append(node)

    # Start the laptop side fake node that just takes in the commands and prints them
    def StartSimulatedRobotNodes(self):
        nodeName = 'laptop_command'
        node = self.StartNode(self.jwaadTestPkgName, nodeName)
        time.sleep(1)
        self.ActiveNodes.append(node)

    # Start the sound player on laptop side
    def StartLaptopNodes(self):
        nodeName = 'sound_player'
        node = self.StartNode(self.musicarePkgName, nodeName)
        time.sleep(1)
        self.ActiveNodes.append(node)

    # Run some code before we close out of this node (Ros does this automatically, but we do it again anyways, just incase)
    def OnExit(self):
        # End pygame
        self.pygame.quit()

        # Close all the nodes we started on launch (though this happens automatically)
        rospy.loginfo("Exiting...")
        for node in self.ActiveNodes:
            node.stop()

        # END ROSCORE HERE, maybe?

        print("Ending...")


    # Start a node and store the reference to it
    def StartNode(self, nodePackage, nodeName):
        node = roslaunch.core.Node(nodePackage, nodeName)

        launch = roslaunch.scriptapi.ROSLaunch()

        launch.start()
        nodeRef = launch.launch(node)
        return nodeRef

    def LoadUserDatabase(self):
        """ Load all users into memory, so we can  """
        self.user_database = []
        
        users = []
        # Get list of all users
        users = glob.glob(self.path_to_userdata + "/*.p")
        if users == []:
            return self.user_database
        for path in users:
            user_data = {}
            with open(path, "rb") as f:
                print("attempting to open {0}".format(path))
                user_data = pickle.load(f)
            self.user_database.append(user_data)

        # Also extract / update names, for log in screen
        self.first_names = []
        self.surnames = []
        for user in self.user_database:
            self.first_names.append(user["name"])
            self.surnames.append(user["surname"])

        return self.user_database

    def SaveNewUser(self, name, surname, DoB):
        """
        Save a New User to System
        name = string of first name
        surname = string of last name
        DoB = string of Date of birth in format dd-mm-yy as integers. e.g: 01-01-99
        """
        file_name = name[0] + surname[0] + DoB[-4:] + ".p"

        # Format data of new user
        data = {}
        data["name"] = name
        data["surname"] = surname
        data["dob"] = DoB
        data["blacklist"] = []
        data["game_data"] = {}

        # Get path and save
        file_path = os.path.join(self.path_to_userdata, file_name)

        # Save to file if it doesnt exist already
        if not os.path.exists(file_path):
            open(file_path, "w").close()
            with open(file_path, "wb") as f:
                pickle.dump(data, f)
            rospy.loginfo("User data saved to {0}".format(file_path))
        else:
            rospy.loginfo("User data not saved, user already exists.")
        return data

    def SignupScreen(self):

        # Input / text boxes
        name_box = InputBox(600, 300, 1000, 200, "First Name")
        surname_box = InputBox(600, 700, 1000, 200, "Last Name")
        dob_box = InputBox(600, 1100, 1000, 200, "dd-mm-yyyy", allowed_chars="0123456789", max_chars=10)
        inputboxes = [name_box, surname_box, dob_box]
        # Check marks
        name_tick = self.create_button("check_mark.png", (1750, 325))
        surname_tick = self.create_button("check_mark.png", (1750, 725))
        dob_tick = self.create_button("check_mark.png", (1750, 1125))
        ticks = {}
        #ticks = {1: name_tick, 2: surname_tick, 3: dob_tick}
        # Buttons
        back_button = self.create_button("tut_back.png", (20, 20))
        confirm_button = self.create_button("blank_button.png", (900, 1500), text="Done")
        buttons = [back_button, confirm_button]


        back = False
        while (not rospy.is_shutdown()) and (self.run) and not back:

            # Handle events
            mouse_pos = self.pygame.mouse.get_pos()
            for event in self.pygame.event.get():

                # Handle events for name box
                event_triggered = name_box.handle_event(event)
                if event_triggered == "KEYDOWN":
                    if (name_box.get_text() is not None) and (name_box.get_text() != ""):
                        ticks["name"] = name_tick
                    else:
                        # If tick is already in our dict, remove it
                        if "name" in ticks:
                            del ticks["name"]

                # Handle events for surname box
                event_triggered = surname_box.handle_event(event)
                if event_triggered == "KEYDOWN":
                    if (surname_box.get_text() is not None) and (surname_box.get_text() != ""):
                        ticks["surname"] = surname_tick
                    else:
                        if "surname" in ticks:
                            del ticks["surname"]

                # Handle events for dob box
                event_triggered = dob_box.handle_event(event)
                if event_triggered == "KEYDOWN":
                    # Add the - at set intervals
                    if event.key != pygame.K_BACKSPACE:
                        if len(dob_box.get_text()) in [2, 5]:
                            dob_box.text += "-"
                    # If backspace over a "-", then take additional char
                    else:
                        if len(dob_box.get_text()) in [3, 6]:
                            dob_box.text = dob_box.text[:-1]
                    # Check length is correct for dob:
                    if len(dob_box.get_text()) == 10:
                        ticks["dob"] = dob_tick
                    else:
                        if "dob" in ticks:
                            del ticks["dob"]

                # Check back button and done button
                back = back_button.get_event(event, mouse_pos)
                done_clicked = confirm_button.get_event(event, mouse_pos)

                # Check "Done"
                if len(ticks.values()) == 3:
                    if done_clicked:
                        new_user = self.SaveNewUser(name_box.get_text(), surname_box.get_text(), dob_box.get_text())
                        self.LoadUserDatabase()
                        back = True
                        print(new_user)

                # Handle on click animation
                if event.type == self.pygame.MOUSEBUTTONUP:  # On mouse release play animation to show where cursor is
                    self.animation_manager.StartTouchAnimation(mouse_pos)  # Play animation

                # Check quit
                if event.type == pygame.QUIT:
                    self.run = False
                    print("Quitting...")

            # Draw background
            self.renderer.DrawBackground(self.background_colour)

            # Update graphics
            for button in buttons:
                button.render(self.window)
            for box in inputboxes:
                box.render(self.window)
            if len(ticks.values()) > 0:
                for tick in ticks.values():
                    tick.render(self.window)
            self.animation_manager.DrawTouchAnimation(self.window)
            self.pygame.display.update()  # Update all drawn objects

            # Cap FPS (save resources)
            self.clock.tick(self.FPS)

    def LogInScreen(self):
        """ Use database, and check if user is inputting credentials we have seen before. """

        # Input / text boxes
        name_box = InputBox(200, 600, 1000, 200, "First Name")
        surname_box = InputBox(1600, 600, 1000, 200, "Last Name")
        inputboxes = [name_box, surname_box]
        # Check marks
        name_tick = self.create_button("check_mark.png", (650, 800))
        surname_tick = self.create_button("check_mark.png", (2050, 800))
        ticks = {}
        # Buttons
        next_button = self.create_button("next_button.png", (1100, 1200))
        signup_button = self.create_button("blank_button.png", (2300, 20), text="New User", scale=0.5)

        log_in = False
        user_recognised = False
        correct_surname = "#}$"
        while (not rospy.is_shutdown()) and (self.run) and not log_in:

            # Handle events
            mouse_pos = self.pygame.mouse.get_pos()
            for event in self.pygame.event.get():

                # Handle on click animation
                if event.type == self.pygame.MOUSEBUTTONUP:  # On mouse release play animation to show where cursor is
                    self.animation_manager.StartTouchAnimation(mouse_pos)  # Play animation

                # Handle events for name box
                event_triggered = name_box.handle_event(event)
                if event_triggered == "KEYDOWN":
                    if name_box.get_text() in self.first_names:
                        ticks["name"] = name_tick
                        # Get the corresponding surname
                        ind = self.first_names.index(name_box.get_text())
                        correct_surname = self.surnames[ind]
                    else:
                        # If tick is already in our dict, remove it
                        if "name" in ticks:
                            del ticks["name"]
                            user_recognised = False
                            correct_surname = "#}$"

                # Handle events for surname box
                event_triggered = surname_box.handle_event(event)
                if event_triggered == "KEYDOWN":
                    if surname_box.get_text() == correct_surname:
                        ticks["surname"] = surname_tick
                        user_recognised = True
                    else:
                        # If tick is already in our dict, remove it
                        if "surname" in ticks:
                            del ticks["surname"]
                            user_recognised = False
                            correct_surname = "#}$"

                # Handle event for next button
                next_clicked = next_button.get_event(event, mouse_pos)
                if next_clicked:
                    if user_recognised:
                        self.user_data = self.user_database[self.surnames.index(surname_box.get_text())]
                        log_in = True
                    else:
                        #TODO add flash or simple animation, to show wrong user here.
                        print("Animation just played, did you see it?")

                # Handle event for new user
                signup = signup_button.get_event(event, mouse_pos)
                if signup:
                    self.SignupScreen()

                # Check quit
                if event.type == pygame.QUIT:
                    self.run = False
                    print("Quitting...")

            # Draw background
            self.renderer.DrawBackground(self.background_colour)

            # Update graphics
            for box in inputboxes:
                box.render(self.window)
            if len(ticks.values()) > 0:
                for tick in ticks.values():
                    tick.render(self.window)
            next_button.render(self.window)
            signup_button.render(self.window)
            self.animation_manager.DrawTouchAnimation(self.window)
            self.pygame.display.update()  # Update all drawn objects

            # Cap FPS (save resources)
            self.clock.tick(self.FPS)

        return self.user_data

    def mood_comment(self, mood_rating):
        """ Using the mood of the user, robot should say something"""
        # max_mood = 7 # the highest and happiest score possible.
        neutral_rating = 3

        # Positive rating
        if mood_rating > neutral_rating:
            # "Thats good" type message
            sayings = ["Thats great news! Then lets get straight into playing!",
                       "I'm so happy to hear that! Then.. lets play some games and have some fun!",
                       "Thats perfect! Then we will enjoy the games even more!",
                       "That makes me happy too! We're going to have so much fun playing these games!"
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = "congratulation" #TODO check if this is real gesture
        # Negative rating
        elif mood_rating < neutral_rating:
            # "That's too bad" type message
            sayings = ["Oh... Thats too bad. Hopefully playing games will cheer you up!",
                       "Oh... Thats too bad. Maybe playing with me can help a bit!",
                       "I'm sorry to hear. Lets play some games! maybe that will make you feel happier",
                       "Maybe playing these games will make you feel more cheerful!",
                       "Oh no! Then, in that case. Hopefully i can cheer you up with the games we'll play!"
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = "shake_head"
        # Neutral rating
        else:
            # "oh? lets fix that" type message
            sayings = ["Hmm, okay maybe playing games will make you feel livelier!",
                       "Oh, okay. Then lets play games. Maybe you'll feel more cheerful after!",
                       "okay. Then... Lets play some games. It might make you feel happier!"
                       ]
            ind = random.randint(0, len(sayings) - 1)
            message = sayings[ind]
            gesture = ""

        if gesture == "":
            self.Levels.QTSpeakingScreen(message, self.run, self.background_colour)
        else:
            self.Levels.QTSpeakingScreen(message, self.run, self.background_colour, should_gesture=True,
                                     gesture=gesture)

    def QTPreamble(self, user):
        name = user["name"]

        # If this is a new user act differently
        if len(user["game_data"]) < 1:
            s_1 = "Hi {}! It's so nice to meet you!... My name is QT robot.".format(name)
            s_2 = "Unfortunately. I can not understand human language..."
            s_3 = "If you want to interact with me, you will need to use the screen."
            s_4 = "Anyways!"

            dialogue = [s_1, s_2, s_3, s_4]
            gestures = ["wave", "shake_head", "show_right", "" ]
            for i in range(0, len(dialogue)):
                print(dialogue[i], gestures[i])
                if gestures[i] == "":
                    self.Levels.QTSpeakingScreen(dialogue[i], self.run, self.background_colour)
                else:
                    self.Levels.QTSpeakingScreen(dialogue[i], self.run, self.background_colour, should_gesture = True,
                                                 gesture = gestures[i])
                time.sleep(1) # Add 1s delay between sentences
        else:
            # Use a randomised greeting
            self.Levels.QTSpeakingScreen(self.behaviours_manager.get_greetings(), self.run, self.background_colour, should_gesture=True,
                                         gesture="wave")

        # Ask user how they are, save to data
        mood_score = 5 # TODO HOW ARE YOU SCREEN
        self.session_data["mood_pre"] = mood_score

        # QT should comment based on their mood e.g: "Oh, hopefully these games cheer you up"
        self.mood_comment(mood_score)


        # introduce the start of the games



    # Create GUI to control which level to play
    def Main(self):

        # Load all users into memory
        self.LoadUserDatabase()

        # use name and surname to get user data
        user = game_manager.LogInScreen()

        # What QT should say to the returning or new user
        self.QTPreamble(user)

        # use session time to gauge how long to play for
        session_start = rospy.get_time()

        # Play levels
        pass

        # Close up shop
        self.OnExit()


if __name__ == '__main__':
    game_manager = GameManager()
    game_manager.Main()